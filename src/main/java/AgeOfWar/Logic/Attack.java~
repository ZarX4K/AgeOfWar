package AgeOfWar.Logic;

import AgeOfWar.Characters.*;
import java.util.List;
import java.util.Map;
import java.util.Random;

public class Attack {
    private static final long ATTACK_INTERVAL = 500; // Milliseconds between attacks
    private static final Random RANDOM = new Random();
    private boolean healthBoostApplied = false;

    public Attack() {
        // Initialization if needed
    }

    // Perform an attack between characters
    public void performAttack(BaseCharacterStats attacker, BaseCharacterStats target,
                              List<? extends BaseCharacterStats> team1, List<? extends BaseCharacterStats> team2, MainLogic mainLogic, Map map) {
        long currentTime = System.currentTimeMillis();

        if (canAttack(attacker, target, currentTime)) {
            if (attacker instanceof CombatType) {
                CombatType combatant = (CombatType) attacker;
                int distance = Math.abs(attacker.getX() - target.getX());

                // Close combat logic (perform only if within close combat range)
                if (distance <= combatant.getCloseCombatRange()) {
                    combatant.performCloseCombatAttack(target);
                    combatant.stopRangedAttack(); // Stop ranged attack if in close range
                } else if (distance <= combatant.getRangedAttackRange() && canSeeEnemy(attacker, target, map)) {
                    // If within ranged attack range and line of sight is clear, perform ranged attack
                    combatant.performRangedAttack(target);
                    combatant.stopCloseCombat(); // Ensure close combat does not happen while ranged
                }

            } else {
                // Generic attack logic for other character types
                int damageDealt = calculateDamage(attacker);
                DAMAGESTATES damageState = determineDamageState(attacker, target, damageDealt);
                applyDamage(target, damageDealt, damageState);
            }

            // Archer specific logic: Spawn arrows if enemies are within range and in line of sight
            if (attacker instanceof Archer) {
                Archer archer = (Archer) attacker;
                int range = archer.getRangedAttackRange();  // Get range from MainLogic
                int distance = Math.abs(attacker.getX() - target.getX());

                // Check if target is within range for archers and if line of sight is clear
                if (distance <= range && canSeeEnemy(attacker, target, map)) {
                    System.out.println(attacker.getClass().getSimpleName() + " shoots an arrow!");
                    mainLogic.spawnProjectile(attacker);  // Spawns the projectile (arrow)
                } else {
                    System.out.println(attacker.getClass().getSimpleName() + " cannot shoot, target too far away or no line of sight.");
                }
            }

            // Tank specific logic: Check if the target is within range and can be attacked
            if (attacker instanceof Tank) {
                Tank tank = (Tank) attacker;
                int range = tank.getRangedAttackRange();  // Get range from MainLogic
                int distance = Math.abs(attacker.getX() - target.getX());

                // Check if target is within range for tanks and if line of sight is clear
                if (distance <= range && canSeeEnemy(attacker, target, map)) {
                    System.out.println(attacker.getClass().getSimpleName() + " attacks with tank range!");
                    mainLogic.spawnProjectile(attacker);  // Spawns the tank's attack
                } else {
                    System.out.println(attacker.getClass().getSimpleName() + " cannot shoot, target too far away or no line of sight.");
                }
            }

            updateLastAttackTime(attacker, currentTime);
            applyHealthBoostIfNeeded(attacker, target);
            handleDefeat(attacker, team1, mainLogic);
            handleDefeat(target, team2, mainLogic);
        }
    }


    // Check if the attacker can attack
    private boolean canAttack(BaseCharacterStats attacker, BaseCharacterStats target, long currentTime) {
        return attacker.isAlive() && target.isAlive() &&
                currentTime - attacker.getLastAttackTime() >= ATTACK_INTERVAL;
    }

    // Example approach without using GameMap or isClearPath
    public boolean canSeeEnemy(BaseCharacterStats attacker, BaseCharacterStats target, Map map) {
        int attackerX = attacker.getX();
        int attackerY = attacker.getY();
        int targetX = target.getX();
        int targetY = target.getY();

        // Check if there's an obstacle in the line between attacker and target
        for (int x = Math.min(attackerX, targetX); x <= Math.max(attackerX, targetX); x++) {
            for (int y = Math.min(attackerY, targetY); y <= Math.max(attackerY, targetY); y++) {
                // Only block the shot if there is an obstacle and it is not a teammate
                if (mapContainsObstacle(x, y, map)) {
                    BaseCharacterStats obstacle = getCharacterAtPosition(x, y, map);
                    if (obstacle != null && obstacle != attacker && obstacle != target && isTeammate(attacker, obstacle)) {
                        return false;  // Block the shot if there's a teammate in the way
                    }
                }
            }
        }

        return true;  // No obstacles found or it's just the target
    }
    public boolean isTeammate(BaseCharacterStats attacker, BaseCharacterStats obstacle) {
        // Check if both are on the same team (you can implement this based on how your teams are structured)
        return (attacker instanceof Archer && obstacle instanceof Archer) ||
                (attacker instanceof Tank && obstacle instanceof Tank);  // Example for Archer and Tank
    }
    public BaseCharacterStats getCharacterAtPosition(int x, int y, Map map) {
        // This should return the character at the specified coordinates, or null if none exists
        return map.getCharacterAt(x, y);  // Modify as needed based on your map's implementation
    }



    // This is a simple placeholder; modify based on how your map stores obstacles
    public boolean mapContainsObstacle(int x, int y, Map map) {
        // Implement this based on your map structure
        return false;  // Example, replace with actual logic
    }

    public class Map {
        private BaseCharacterStats[][] grid;  // Example grid representing the map

        // Constructor or initialization logic for the map
        public Map(int width, int height) {
            grid = new BaseCharacterStats[width][height];  // Initialize a 2D grid
        }

        // Method to set a character at a specific location
        public void setCharacterAt(int x, int y, BaseCharacterStats character) {
            grid[x][y] = character;
        }

        // Method to get a character at a specific location
        public BaseCharacterStats getCharacterAt(int x, int y) {
            if (x >= 0 && x < grid.length && y >= 0 && y < grid[0].length) {
                return grid[x][y];  // Return the character at the grid position
            }
            return null;  // Return null if the position is out of bounds or no character is present
        }
    }


    // Calculate damage with random critical hit logic
    private int calculateDamage(BaseCharacterStats attacker) {
        int baseDamage = attacker.getDamage();
        boolean criticalHit = RANDOM.nextInt(100) < 20;

        if (criticalHit && attacker instanceof Knight) {
            Knight knight = (Knight) attacker;
            int criticalDamage = knight.getCritical();
            System.out.println(knight.getClass().getSimpleName() + " landed a critical hit! Damage: " + criticalDamage);
            return criticalDamage;
        }

        return baseDamage;
    }

    // Determine the damage state
    private DAMAGESTATES determineDamageState(BaseCharacterStats attacker, BaseCharacterStats target, int damage) {
        if (target instanceof Tank && RANDOM.nextInt(100) < 10) {
            return DAMAGESTATES.ARMOR_ACTIVATED;
        } else if (attacker instanceof Knight && damage > attacker.getDamage()) {
            return DAMAGESTATES.CRITICAL_ACTIVATED;
        }
        return DAMAGESTATES.NORMAL;
    }

    // Apply damage to a target based on damage state
    private void applyDamage(BaseCharacterStats target, int damage, DAMAGESTATES damageState) {
        int finalDamage = damage;

        switch (damageState) {
            case ARMOR_ACTIVATED:
                if (target instanceof Tank) {
                    Tank tank = (Tank) target;
                    finalDamage = Math.max(0, damage - tank.getArmor());
                }
                System.out.println("Armor activated! Reduced damage to " + finalDamage + ".");
                break;

            case CRITICAL_ACTIVATED:
                System.out.println("Critical hit! Damage dealt: " + finalDamage);
                break;

            case NORMAL:
                System.out.println("Normal damage: " + finalDamage);
                break;
        }

        target.takeDamage(finalDamage);
    }

    // Update the last attack time for the attacker
    private void updateLastAttackTime(BaseCharacterStats attacker, long currentTime) {
        attacker.setLastAttackTime(currentTime);
    }

    // Apply health boost if needed
    private void applyHealthBoostIfNeeded(BaseCharacterStats attacker, BaseCharacterStats target) {
        if (!healthBoostApplied && attacker.getClass() == target.getClass() &&
                attacker.getHealth() <= 100 && target.getHealth() <= 100) {
            if (RANDOM.nextBoolean()) {
                attacker.setHealth(attacker.getHealth() + 25);
            } else {
                target.setHealth(target.getHealth() + 25);
            }
            healthBoostApplied = true;
        }
    }

    // Handle character defeat
    private void handleDefeat(BaseCharacterStats character, List<? extends BaseCharacterStats> team, MainLogic mainLogic) {
        if (character.getHealth() <= 0) {
            mainLogic.awardGoldForKill(character);
            team.remove(character);
        } else {
            character.setMoving(true);
        }
    }

    // Perform an attack on a castle
    public void performAttackOnCastle(BaseCharacterStats character, Castle castle) {
        long currentTime = System.currentTimeMillis();

        if (character.isAlive() && currentTime - character.getLastAttackTime() >= ATTACK_INTERVAL) {
            int damage = character.getDamage();
            castle.takeDamage(damage);
            character.setLastAttackTime(currentTime);
            character.setMoving(false);
        }
    }
}
